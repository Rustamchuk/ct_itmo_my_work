package main

import (
	"fmt"
	"strings"
)

/*
К каким негативным последствиям может привести данный фрагмент кода,
и как это исправить? Приведите корректный пример реализации.

var justString string
func someFunc() {
  v := createHugeString(1 << 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
*/

/*
v := createHugeString(1 << 10) - создаем строку длины 1024.
Дальше в коде хотим использовать только 100 символов оттуда.
Но justString = v[:100] - берет 100 символов и остальные оставляет на фоне, не удаляя.
Сборщик мусора не очищает неиспользуемые символы, так как переменная justString глобальная.

Но justString не использует все 1024 символа. Почему сборщик мусора не удалит?
Новый срез строки не создает новую копию данных строки.
Вместо этого, он создает новую структуру string, которая ссылается на те же данные в памяти, что и исходная строка v.
Эта новая строка justString просто имеет другую длину и (возможно) другой начальный индекс,
но данные в памяти остаются общими с исходной строкой v.
*/

func createHugeString(size int) string {
	var s string
	for i := 0; i < size; i++ {
		s += "a" // Просто пример, создающий большую строку
	}
	return s
}

var justString string

func someFunc() {
	v := createHugeString(1 << 10)
	// Клонированием отвязываемся от текущего участка в памяти
	justString = strings.Clone(v[:100])
	fmt.Println(justString)
}

func main() {
	someFunc()
}
