a)
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
    a = 1
    p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Данный код выведет "1\n1\n". Ответ в том, что обязательно надо ставить &, когда ставишь в аргумент метода переменнаю, которую хочешь позволить менять. То есть update(p) отправляет наш указатель на единицу, но сам метод update принимает эту переменную, КОПИРУЯ ее, и уже работает с ее копией, поэтому как бы мы не меняли переменную в методе, оригинал не изменится. Если мы хотим, чтобы оригинал изменился, то придется сделать update(&p), отправить в метод указатель на указатель, так метод update сможет изменить оригинал, но и его придется изменить немного, чтобы работал с указателем на указатель, а не с указателем на значение. Вот код

func update(p **int) {
  b := 2
  *p = &b
}

func main() {
  var (
    a = 1
    p = &a
  )
  fmt.Println(*p)
  update(&p)
  fmt.Println(*p)
}

В методе update я получаю указатель на указатель и заменяю узказатель на который он указывает, на указатель на новое значение. Ну в общем p шаг назад = b шаг вперед, если можно так выразиться. Поменяли значение указателя p
Вернем "1\n2\n". 

Еще кстати есть второй способ. Так как к нам приходит копия p, она все равно указывает на единицу, просто при ее замене она начнет указывать на другое. То есть мы можем просто по ее указателю пройти и заменить значение, на которое она указывает. указатель останется, а ячейку подменим

func update(p *int) {
  b := 2
  *p = b
}

func main() {
  var (
    a = 1
    p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
"1\n2\n"

Произошла подмена значения, куда указывает p. Поменяли a

b) Нет нельзя, слайсы динамически расширяются, но функции удаления нет. Но как это и возможно вообще, раз слайсы это обертка обычных массивов, то удалить элемент посередине, значит как-то освободить ячейку памяти. Чтобы это сделать можно будто бы сделать append(s[:i], s[i+1:]), но это все равно не позволит нам уменьшить длину забронированной памяти (ячеек), в итоге на конце будет число, которое и стояло. проблема в том, что, забронировав длину ячеек подряд в памяти, уже нельзя просто взять и отбранировать, надо найти новое место в памяти с нужным кол-вом ячеек, а прошлые отбранировать. Получается создать новый массив

с) Можно, тут как в пункте (а) первый способ

func swapPointers(a, b **int) {
	c := *a
	*a = *b
	*b = c
}

func main() {
	i, j := 1, 2
	a, b := &i, &j
	swapPointers(&a, &b)
	fmt.Println(i, j, *a, *b)
}

Просто передаем указатель на указатель. Внутри swap меняем местами указатели на которые указываем. a -> *a | c -> *a => a -> *b | b -> c
Поменяли указатели, а не значения
